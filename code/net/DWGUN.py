from torch import nn, cat
from torch.nn import functional as F
from net.ResBlock import ResBlock, transResBlock
from utils.box_filter import BoxFilter


class edgeAwareNet(nn.Module):
    """
    edge aware net for DWGF to generate weight matrix for guide map using spatial attention
    """

    def __init__(self, in_channel, c=16):
        super(edgeAwareNet, self).__init__()
        self.ResStack = nn.Sequential(
            ResBlock(in_channel, c),
            ResBlock(c, c),
            ResBlock(c, 2*c),
            ResBlock(2*c, 2*c),
            ResBlock(2*c, c),
            ResBlock(c, c),
            ResBlock(c, in_channel),
            nn.Conv2d(in_channel, in_channel, 1,
                      stride=1, padding=0, dilation=1),
        )

    def forward(self, x):
        return nn.Sigmoid()(x+self.ResStack(x))


class FastWeightedGuidedFilter(nn.Module):
    def __init__(self, r, c=16, eps=1e-8):
        super(FastWeightedGuidedFilter, self).__init__()

        self.r = r
        self.eps = eps
        self.boxfilter = BoxFilter(r)
        self.edgeAware = edgeAwareNet(3, c)

    def forward(self, lr_x, lr_y, hr_x):
        n_lrx, c_lrx, h_lrx, w_lrx = lr_x.size()
        n_lry, c_lry, h_lry, w_lry = lr_y.size()
        n_hrx, c_hrx, h_hrx, w_hrx = hr_x.size()

        assert n_lrx == n_lry and n_lry == n_hrx
        assert c_lrx == c_hrx and (c_lrx == 1 or c_lrx == c_lry)
        assert h_lrx == h_lry and w_lrx == w_lry
        assert h_lrx > 2*self.r+1 and w_lrx > 2*self.r+1

        # N
        N = self.boxfilter(
            lr_x.data.new().resize_((1, 3, h_lrx, w_lrx)).fill_(1.0))

        # mean_x
        mean_x = self.boxfilter(lr_x) / N
        # mean_y
        mean_y = self.boxfilter(lr_y) / N
        # cov_xy
        cov_xy = self.boxfilter(lr_x * lr_y) / N - mean_x * mean_y
        # var_x
        var_x = self.boxfilter(lr_x * lr_x) / N - mean_x * mean_x

        # edge aware matrix generated by deep edge aware module
        edgeWeight = self.edgeAware(lr_y)

        # A
        A = cov_xy / (var_x + self.eps + edgeWeight)
        # b
        b = mean_y - A * mean_x

        # mean_A; mean_b
        mean_A = F.interpolate(
            A, (h_hrx, w_hrx), mode='bilinear', align_corners=True)
        mean_b = F.interpolate(
            b, (h_hrx, w_hrx), mode='bilinear', align_corners=True)

        return mean_A*hr_x+mean_b, edgeWeight, self.boxfilter(lr_x), self.boxfilter(lr_y)


class refocusRefineModule(nn.Module):
    """
    channel attention module to refine the DOF effects between guidedUpsamleRF, interpolatedRF, hrFF
    """

    def __init__(self, c=16):
        super(refocusRefineModule, self).__init__()
        self.transConvA = nn.Sequential(
            transResBlock(9, c),
            transResBlock(c, c),
            transResBlock(c, 2*c),
            transResBlock(2*c, 2*c),
            transResBlock(2*c, c),
            transResBlock(c, 3),
            nn.ConvTranspose2d(3, 3, kernel_size=3,
                               stride=1, padding=1),
            nn.Softmax(dim=1)
        )

    def forward(self, guidedUpsamleRF, interpolatedRF, hrFF):
        # soft atttention to refine the final output
        # get weight between hrRF, hrRFInterpolated, hrFF
        weight = self.transConvA(
            cat([guidedUpsamleRF, interpolatedRF, hrFF], dim=1))

        return weight[:, 0:1, ...]*guidedUpsamleRF+weight[:, 1:2, ...]*interpolatedRF+weight[:, 2:3, ...]*hrFF


class DWGUN(nn.Module):
    """
    following the traditional process in weighted guided filter
    """

    def __init__(self, radius=1, c=16, dilation=0, norm=nn.BatchNorm2d):
        super(DWGUN, self).__init__()
        self.exFF = nn.Sequential(
            ResBlock(3, c),
            ResBlock(c, c),
            ResBlock(c, 2*c),
            ResBlock(2*c, 2*c),
            ResBlock(2*c, c),
            ResBlock(c, 3),
            nn.Conv2d(3, 3, 1, stride=1, padding=0, dilation=1)
        )
        self.exRF = nn.Sequential(
            ResBlock(3, c),
            ResBlock(c, c),
            ResBlock(c, 3),
            nn.Conv2d(3, 3, 1, stride=1, padding=0, dilation=1)
        )
        self.recovRF = nn.Sequential(
            transResBlock(3, c),
            transResBlock(c, c),
            transResBlock(c, 3),
            nn.ConvTranspose2d(3, 3, 1, stride=1, padding=0, dilation=1),
            nn.Sigmoid()
        )
        self.weightedGuidedFilter = FastWeightedGuidedFilter(r=radius, c=c)
        self.refineAttention = refocusRefineModule(c=c)

        # self.MLRM = MultiLevelRefineModule()

    def forward(self, lrRF, hrFF):
        _, _, h_lrx, w_lrx = lrRF.size()
        _, _, h_hrx, w_hrx = hrFF.size()
        lrFF = F.interpolate(
            hrFF, (h_lrx, w_lrx), mode='bilinear', align_corners=True)
        hrRFInterpolated = F.interpolate(
            lrRF, (h_hrx, w_hrx), mode='bilinear', align_corners=True)

        # feature extraction to generate a linear relationship between RF<->FF
        lrRFFeature = self.exRF(lrRF)
        lrFFFeature = self.exFF(lrFF)
        hrFFFeature = self.exFF(hrFF)

        # weighted guided filter to generate hr RF
        output1, edgeWeight, FF, RF = self.weightedGuidedFilter(
            lrFFFeature, lrRFFeature, hrFFFeature)

        # feature recover
        if self.recovRF is not None:
            output = self.recovRF(output1)

        # refocus refine module with feature recover
        if self.refineAttention is not None:
            output = self.refineAttention(output, hrRFInterpolated, hrFF)

        return self.recovRF(output), output1, RF, edgeWeight
